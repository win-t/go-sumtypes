//go:build ignore

package main

import (
	"fmt"
	"os"
	"strconv"
)

func main() {
	for i := 2; i <= 32; i++ {
		check(os.MkdirAll(fmt.Sprintf("sum%d", i), 0o755))
		check(os.WriteFile(fmt.Sprintf("sum%d/sum.go", i), []byte(generate(i)), 0o644))
	}
}

func check(err error) {
	if err != nil {
		panic(err)
	}
}

func generate(count int) string {
	Tlist := ``
	for i := 0; i < count; i++ {
		if i != 0 {
			Tlist += `, `
		}
		i := strconv.Itoa(i)
		Tlist += `T` + i
	}

	fList := ``
	for i := 0; i < count; i++ {
		if i != 0 {
			fList += `, `
		}
		i := strconv.Itoa(i)
		fList += `f` + i + ` func(T` + i + `)`
	}

	code := `
// Code generated by "go-sumtypes/generate.go". DO NOT EDIT.

package sum` + strconv.Itoa(count) + `

import "reflect"

type Type[` + Tlist + ` any] struct {
	v any
}
`
	for i := 0; i < count; i++ {
		i := strconv.Itoa(i)
		code += `
func (s *Type[` + Tlist + `]) Set` + i + `(v T` + i + `) {
	s.v = v
}

func (s Type[` + Tlist + `]) Get` + i + `() (T` + i + `, bool) {
	v, ok := s.v.(T` + i + `)
	return v, ok
}
`
	}

	code += `
func (s Type[` + Tlist + `]) Case(` + fList + `) {
	switch v := s.v.(type) {`
	for i := 0; i < count; i++ {
		i := strconv.Itoa(i)
		code += `
	case T` + i + `:
		if f` + i + ` == nil {
			noHandler(v)
		}
		f` + i + `(v)`
	}
	code += `
	default:
		panic("called Case on an invalid value")
	}
}

func noHandler(v any) {
	panic("no handler for case " + reflect.TypeOf(v).String())
}
`
	return code[1:]
}
