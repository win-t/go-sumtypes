//go:build ignore

package main

import (
	"fmt"
	"os"
	"strconv"
)

func main() {
	for i := 2; i <= 16; i++ {
		check(os.RemoveAll(fmt.Sprintf("sum%d", i)))
		check(os.Mkdir(fmt.Sprintf("sum%d", i), 0o755))
		check(os.WriteFile(fmt.Sprintf("sum%d/sum.go", i), []byte(generate(i)), 0o644))
	}
}

func check(err error) {
	if err != nil {
		panic(err)
	}
}

func generate(count int) string {
	t := genTypeGeneric(count)
	f := genFunctionParam(count)

	ret := `// Code generated by "go-sumtypes/generate.go". DO NOT EDIT.

package sum` + strconv.Itoa(count) + `

import "reflect"

type Type[` + t + ` any] struct {
	v any
}
`
	for i := 0; i < count; i++ {
		i := strconv.Itoa(i)
		ret += `
func (s *Type[` + t + `]) Set` + i + `(v T` + i + `) {
	s.v = v
}

func (s Type[` + t + `]) As` + i + `() (T` + i + `, bool) {
	v, ok := s.v.(T` + i + `)
	return v, ok
}
`
	}

	ret += `
func (s Type[` + t + `]) Case(` + f + `) {
	switch v := s.v.(type) {`
	for i := 0; i < count; i++ {
		i := strconv.Itoa(i)
		ret += `
	case T` + i + `:
		if f` + i + ` == nil {
			panic("no handler for case " + reflect.TypeOf(v).String())
		}
		f` + i + `(v)`
	}
	ret += `
	default:
		panic("called Case on an invalid value")
	}
}
`
	return ret
}

func genTypeGeneric(count int) string {
	ret := ""
	for i := 0; i < count; i++ {
		if i != 0 {
			ret += ", "
		}
		ret += fmt.Sprintf("T%d", i)
	}
	return ret
}

func genFunctionParam(count int) string {
	ret := ""
	for i := 0; i < count; i++ {
		if i != 0 {
			ret += ", "
		}
		ret += fmt.Sprintf("f%d func(T%d)", i, i)
	}
	return ret
}
