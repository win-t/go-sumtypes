package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
)

type sumtype struct {
	base string
	elem []string
}

func main() {
	name := os.Getenv("GOFILE")
	if len(os.Args) > 1 {
		name = os.Args[1]
	}
	if name == "" {
		fmt.Fprintf(os.Stderr, "usage: %s <file.go>\n", os.Args[0])
		os.Exit(1)
	}

	if absName, err := filepath.Abs(name); err == nil {
		name = absName
	}

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, name, nil, parser.SkipObjectResolution)
	check(err)

	getPos := func(p token.Pos) string {
		return fset.Position(p).String()
	}

	var sumtypes []sumtype

	for _, d := range file.Decls {
		decl, ok := d.(*ast.GenDecl)
		if !ok {
			continue
		}

		if decl.Tok != token.TYPE {
			continue
		}

	nextType:
		for _, s := range decl.Specs {
			tspec, ok := s.(*ast.TypeSpec)
			if !ok {
				continue
			}

			ispec, ok := tspec.Type.(*ast.InterfaceType)
			if !ok {
				continue
			}

			markerfound := false
			for _, m := range ispec.Methods.List {
				if m.Names[0].Name == "sumtype" && len(m.Type.(*ast.FuncType).Params.List) == 0 {
					markerfound = true
					break
				}
			}
			if !markerfound {
				continue
			}

			fmt.Printf("found sum type: %s: %s\n", tspec.Name, getPos(tspec.Pos()))

			var caseFunc *ast.FuncType
			for _, m := range ispec.Methods.List {
				if m.Names[0].Name == "Case" {
					caseFunc = m.Type.(*ast.FuncType)
				}
			}
			if caseFunc == nil {
				fmt.Printf("cannot process %s: \"Case\" method not found\n", tspec.Name)
				continue
			}

			sum := sumtype{base: tspec.Name.Name}
			for _, p := range caseFunc.Params.List {
				typ := getCaseType(p)
				if typ == "" {
					fmt.Printf("cannot process %s: invalid \"Case\" func: %s\n", tspec.Name, getPos(p.Pos()))
					continue nextType
				}
				sum.elem = append(sum.elem, typ)
			}

			sumtypes = append(sumtypes, sum)
		}
	}

	if len(sumtypes) > 0 {
		dir := filepath.Dir(name)
		genName := filepath.Base(name)
		genName = genName[:len(genName)-3] + "_generated_sumtypes.go"
		generate(dir, genName, file.Name.Name, sumtypes)
	}
}

func getCaseType(param *ast.Field) string {
	ft, ok := param.Type.(*ast.FuncType)
	if !ok {
		return ""
	}

	ftparam := ft.Params.List
	if len(ftparam) != 1 {
		return ""
	}

	switch t := ftparam[0].Type.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		i, ok := t.X.(*ast.Ident)
		if !ok {
			return ""
		}
		return "*" + i.Name
	default:
		return ""
	}
}

func generate(dir, name, pkg string, sumtypes []sumtype) {
	code := `
// Code generated by "github.com/win-t/go-sumtypes". DO NOT EDIT.

package ` + pkg

	for _, g := range sumtypes {
		for i, t := range g.elem {
			code += `
func(` + t + `)sumtype(){}
func(s ` + t + `)Case(` + genCaseSignature(i, g.elem) + `){f(s)}`
		}
	}

	fname := filepath.Join(dir, name)
	err := os.WriteFile(fname, []byte(code[1:]), 0o644)
	check(err)
	fmt.Printf("generated: %s\n", fname)
}

func genCaseSignature(idx int, group []string) string {
	ret := ""
	for i, t := range group {
		if i != 0 {
			ret += `,`
		}
		if i != idx {
			ret += `_ `
		} else {
			ret += `f `
		}
		ret += `func(` + t + `)`
	}
	return ret
}

func check(err error) {
	if err != nil {
		panic(err)
	}
}
